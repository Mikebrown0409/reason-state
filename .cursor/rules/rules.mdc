---
alwaysApply: true
---

# Reason-State Pivot Rules (JSON-first governed graph)

## Core principles
- JSON-first: no graph DB required. State is structured JSON with nodes, edges, append-only patch log, periodic checkpoints, deterministic replay.
- Details vs summaries: details are authoritative (never LLM-mutated); summaries are LLM-facing and must be faithful.
- No deletes: patches cannot delete nodes. Changes are append-only mutations via validated patch DSL.
- Governance first: unknown/dirty/invalid assumptions block actions; contradictions trigger self-heal; lineage is required (`sourceType/sourceId`).

## Data model (minimum)
- Node fields: `id`, `type` (fact/assumption/unknown/decision/action/planning/external), `summary`, `details`, `status` (open/resolved/blocked/assumed/missing), `parentId`, `children[]`, `sourceType/sourceId`, `assumptionStatus`, timestamps, optional metadata (tool args, expiration).
- Edges: stored as adjacency on nodes; supported relations include `depends_on`, `contradicts`, `temporal_before/after`, `subgoal_of`, `inferred_from`.
- Logs & checkpoints: maintain append-only patch log; checkpoint every N patches/turns; support deterministic rebuild/replay.

## Patch DSL (validated, Zod)
Allowed ops: `updateSummary`, `setStatus`, `addChildNode`, `linkNodes`, `createUnknownNode`, `resolveUnknown`, `promoteToParent`, `mergeNodes`. No deletes. IDs must exist (except for new nodes). Summaries must not invent data absent in details.

## Reconciliation & dirty propagation
- Dirty triggers: detail update, parent change, structural link/merge, contradiction.
- Propagation: node → parent → depends_on/children as needed.
- Self-heal: contradictions mark involved nodes dirty and resolve via patches; re-run reconciliation.

## Context builder (must use)
- Deterministic, token-budgeted, summaries-only. Priority buckets: goals/constraints → blockers/unknowns → active plans → top-K facts/assumptions by relevance/recency → minimal timeline. Stable ordering for replay.

## Tool realism (Rule #6 aligned)
- `xSearch`: real X API; if no key, use live public X search with `start_time>=2025-12-06` (no canned data). Must emit assumptions with `sourceId=post_id`, `sourceType=x-post`, include text/media where available.
- `grokChat`: Grok 4.1 only; no mock; `grokPlanPatch` must carry lineage.
- Booking: real-ish (e.g., Stripe test + calendar clash). Must block if `unknowns`/`dirty` present (`canExecute` gate). No no-op mocks.

## Agent/orchestrator expectations
- JSON-native DAG (or LangGraph/Temporal-lite) with nodes: gate → researchX → planWithGrok → bookTravel → selfHeal → replay. Checkpoints per turn. Replay reuses valid artifacts; regenerates dirty dependents.

## Demo acceptance (Jarvis track)
- Scenario: Tokyo → retract destination → Amsterdam replay. Assert: same flights if budget unchanged, different hotels, >80% token savings, no full reroll.
- UI proof: lineage-rich X post previews (text/media), plan, booking artifacts; governance panel showing unknown/dirty blockers; determinism check visible.

## Testing requirements
- Vitest (or equivalent) integration tests with live calls (rate-limited).
- Tests for: deterministic rebuild from log+checkpoint, context builder token budgeting, replay scenario above, governance gating (unknown/dirty/invalid assumptions), contradiction self-heal.

## Failure policy
- If real X/Grok unavailable: fail loud (“Cannot generate — violates Rule #6 (no mocks). Provide API key or use live public X data fallback.”).
- Repeated invalid patches: backoff and block affected nodes until details change.

